/** @license React vundefined
 * eslint-plugin-react-hooks.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';function S(a){return"Identifier"===a.type?/^use[A-Z0-9].*$/.test(a.name):"MemberExpression"===a.type&&!a.computed&&S(a.property)?(a=a.object,"Identifier"===a.type&&"React"===a.name):!1}function aa(a){return"Identifier"===a.type?!/^[a-z]/.test(a.name):!1}function ba(a){for(;a;){var e=ca(a);if(e&&(aa(e)||S(e)))return!0;a=a.parent}return!1}
function ca(a){if("FunctionDeclaration"===a.type||"FunctionExpression"===a.type&&a.id)return a.id;if("FunctionExpression"===a.type||"ArrowFunctionExpression"===a.type)return"VariableDeclarator"===a.parent.type&&a.parent.init===a?a.parent.id:"AssignmentExpression"===a.parent.type&&a.parent.right===a&&"="===a.parent.operator?a.parent.left:"Property"!==a.parent.type||a.parent.value!==a||a.parent.computed?"AssignmentPattern"!==a.parent.type||a.parent.right!==a||a.parent.computed?void 0:a.parent.left:
a.parent.key}
function V(a){function e(){return{isRequired:!1,isSatisfiedRecursively:!1,hasRequiredNodesBelow:!1,children:new Map}}function b(a,d){d=d.split(".");var m=!0,k=!1,b=void 0;try{for(var h=d[Symbol.iterator](),p;!(m=(p=h.next()).done);m=!0){var z=p.value,g=a.children.get(z);g||(g=e(),a.children.set(z,g));a=g}}catch(E){k=!0,b=E}finally{try{m||null==h.return||h.return()}finally{if(k)throw b;}}return a}function h(a,d,e){d=d.split(".");var m=!0,k=!1,b=void 0;try{for(var h=d[Symbol.iterator](),g;!(m=(g=h.next()).done);m=
!0){var z=a.children.get(g.value);if(!z)break;e(z);a=z}}catch(E){k=!0,b=E}finally{try{m||null==h.return||h.return()}finally{if(k)throw b;}}}function d(a,e,k,h){a.children.forEach(function(a,m){var b=h(m);a.isSatisfiedRecursively?a.hasRequiredNodesBelow&&k.add(b):a.isRequired?e.add(b):d(a,e,k,function(a){return b+"."+a})})}var z=a.dependencies,l=a.declaredDependencies,v=a.optionalDependencies,k=a.externalDependencies,C=a.isEffect,F=e();z.forEach(function(a,d){b(F,d).isRequired=!0;h(F,d,function(a){a.hasRequiredNodesBelow=
!0})});l.forEach(function(a){b(F,a.key).isSatisfiedRecursively=!0});v.forEach(function(a){b(F,a).isSatisfiedRecursively=!0});a=new Set;var g=new Set;d(F,a,g,function(a){return a});var u=[],x=new Set,A=new Set;l.forEach(function(a){a=a.key;g.has(a)?-1===u.indexOf(a)?u.push(a):A.add(a):!C||a.endsWith(".current")||k.has(a)?x.add(a):-1===u.indexOf(a)&&u.push(a)});a.forEach(function(a){u.push(a)});return{suggestedDependencies:u,unnecessaryDependencies:x,duplicateDependencies:A,missingDependencies:a}}
function da(a){var e=a.declaredDependenciesNode,b=a.componentScope,h=a.scope;return a.declaredDependencies.map(function(a){a=b.set.get(a.key);if(null==a)return null;var d=a.defs[0];return null==d?null:"Variable"===d.type&&"VariableDeclarator"===d.node.type&&null!=d.node.init&&("ArrowFunctionExpression"===d.node.init.type||"FunctionExpression"===d.node.init.type)||"FunctionName"===d.type&&"FunctionDeclaration"===d.node.type?a:null}).filter(Boolean).map(function(a){var d=a.defs[0];a:{for(var b=!1,v=
0;v<a.references.length;v++){var k=a.references[v];if(k.writeExpr)if(b){a=!0;break a}else{b=!0;continue}for(var C=k.from;C!==h&&null!=C;)C=C.upper;if(C!==h&&!ea(e,k.identifier)){a=!0;break a}}a=!1}return{fn:d,suggestUseCallback:a}})}function fa(a){return"MemberExpression"!==a.parent.type||a.parent.object!==a||"current"===a.parent.property.name||a.parent.computed||null!=a.parent.parent&&"CallExpression"===a.parent.parent.type&&a.parent.parent.callee===a.parent?a:fa(a.parent)}
function X(a){if("Identifier"===a.type)return a.name;if("MemberExpression"!==a.type||a.computed)throw Error("Unsupported node type: "+a.type);var e=X(a.object);a=X(a.property);return e+"."+a}function ja(a){return"MemberExpression"!==a.type||"Identifier"!==a.object.type||"React"!==a.object.name||"Identifier"!==a.property.type||a.computed?a:a.property}
function ka(a,e){var b=ja(a);if("Identifier"!==b.type)return null;switch(b.name){case "useEffect":case "useLayoutEffect":case "useCallback":case "useMemo":return 0;case "useImperativeHandle":return 1;default:if(b===a&&e&&e.additionalHooks){try{var h=X(b)}catch(d){if(/Unsupported node type/.test(d.message))return 0;throw d;}return e.additionalHooks.test(h)?0:-1}return-1}}
function Y(a,e){for(var b=[a],h=null;b.length;){h=b.shift();if("Identifier"===h.type&&h.name===e.name&&h.range[0]===e.range[0]&&h.range[1]===e.range[1])return h;if(ea(h,e)){a=0;for(var d=Object.entries(h);a<d.length;a++){var z=d[a],l=z[1];"parent"!==z[0]&&(la(l)?(l.parent=h,b.push(l)):Array.isArray(l)&&l.forEach(function(a){la(a)&&(a.parent=h,b.push(a))}))}}}return null}
function ma(a){for(var e="",b=0;b<a.length;b++)e+=a[b],0===b&&2===a.length?e+=" and ":b===a.length-2&&2<a.length?e+=", and ":b<a.length-1&&(e+=", ");return e}function la(a){return"object"===typeof a&&null!==a&&!Array.isArray(a)&&"string"===typeof a.type}function ea(a,e){return a.range[0]<=e.range[0]&&a.range[1]>=e.range[1]}
module.exports={rules:{"rules-of-hooks":{create:function(a){var e=[],b=[];return{onCodePathSegmentStart:function(a){return b.push(a)},onCodePathSegmentEnd:function(){return b.pop()},onCodePathStart:function(){return e.push(new Map)},onCodePathEnd:function(b,d){function h(a){var d=h.cache,c=d.get(a.id);if(null===c){if(!C.has(a.id)){C.add(a.id);d=!0;c=!1;var n=void 0;try{for(var f=a.prevSegments[Symbol.iterator](),B;!(d=(B=f.next()).done);d=!0)h(B.value)}catch(L){c=!0,n=L}finally{try{d||null==f.return||
f.return()}finally{if(c)throw n;}}}return 0}if(void 0!==c)return c;d.set(a.id,null);if(b.thrownSegments.includes(a))c=0;else if(0===a.prevSegments.length)c=1;else{c=0;f=!0;B=!1;var e=void 0;try{n=a.prevSegments[Symbol.iterator]();for(var k;!(f=(k=n.next()).done);f=!0)c+=h(k.value)}catch(L){B=!0,e=L}finally{try{f||null==n.return||n.return()}finally{if(B)throw e;}}}a.reachable&&0===c?d.delete(a.id):d.set(a.id,c);return c}function l(a){var d=l.cache,c=d.get(a.id);if(null===c){if(!C.has(a.id)){C.add(a.id);
d=!0;c=!1;var n=void 0;try{for(var f=a.nextSegments[Symbol.iterator](),B;!(d=(B=f.next()).done);d=!0)l(B.value)}catch(L){c=!0,n=L}finally{try{d||null==f.return||f.return()}finally{if(c)throw n;}}}return 0}if(void 0!==c)return c;d.set(a.id,null);if(b.thrownSegments.includes(a))c=0;else if(0===a.nextSegments.length)c=1;else{c=0;f=!0;B=!1;var e=void 0;try{n=a.nextSegments[Symbol.iterator]();for(var k;!(f=(k=n.next()).done);f=!0)c+=l(k.value)}catch(L){B=!0,e=L}finally{try{f||null==n.return||n.return()}finally{if(B)throw e;
}}}d.set(a.id,c);return c}function v(a){var d=v.cache,c=d.get(a.id);if(null===c)return Infinity;if(void 0!==c)return c;d.set(a.id,null);if(0===a.prevSegments.length)c=1;else{c=Infinity;var n=!0,f=!1,B=void 0;try{for(var b=a.prevSegments[Symbol.iterator](),e;!(n=(e=b.next()).done);n=!0){var k=v(e.value);k<c&&(c=k)}}catch(na){f=!0,B=na}finally{try{n||null==b.return||b.return()}finally{if(f)throw B;}}c+=1}d.set(a.id,c);return c}var k=e.pop();if(0!==k.size){var C=new Set;h.cache=new Map;l.cache=new Map;
v.cache=new Map;var F=l(b.initialSegment),g=ca(d),u=ba(d),x=g?aa(g)||S(g):!1,A=Infinity,m=!0,p=!1,I=void 0;try{for(var t=b.finalSegments[Symbol.iterator](),K;!(m=(K=t.next()).done);m=!0){var W=K.value;if(W.reachable){var R=v(W);R<A&&(A=R)}}}catch(G){p=!0,I=G}finally{try{m||null==t.return||t.return()}finally{if(p)throw I;}}m=!0;p=!1;I=void 0;try{for(var y=k[Symbol.iterator](),P;!(m=(P=y.next()).done);m=!0){var E=P.value,D=E[0],M=E[1];if(D.reachable){var J=0===D.nextSegments.length?A<=v(D):A<v(D),T=
h(D)*l(D),H=C.has(D.id);k=!0;t=!1;K=void 0;try{for(var w=M[Symbol.iterator](),N;!(k=(N=w.next()).done);k=!0){var r=N.value;H&&a.report({node:r,message:'React Hook "'+a.getSource(r)+'" may be executed more than once. Possibly because it is called in a loop. React Hooks must be called in the exact same order in every component render.'});if(x){if(!H&&T!==F){var U='React Hook "'+a.getSource(r)+'" is called conditionally. React Hooks must be called in the exact same order in every component render.'+
(J?" Did you accidentally call a React Hook after an early return?":"");a.report({node:r,message:U})}}else if(!d.parent||"MethodDefinition"!==d.parent.type&&"ClassProperty"!==d.parent.type||d.parent.value!==d)if(g){var O='React Hook "'+a.getSource(r)+'" is called in '+('function "'+a.getSource(g)+'" ')+"which is neither a React function component or a custom React Hook function.";a.report({node:r,message:O})}else if("Program"===d.type){var Q='React Hook "'+a.getSource(r)+'" cannot be called at the top level. React Hooks must be called in a React function component or a custom React Hook function.';
a.report({node:r,message:Q})}else if(u){var q='React Hook "'+a.getSource(r)+'" cannot be called inside a callback. React Hooks must be called in a React function component or a custom React Hook function.';a.report({node:r,message:q})}}}catch(G){t=!0,K=G}finally{try{k||null==w.return||w.return()}finally{if(t)throw K;}}}}}catch(G){p=!0,I=G}finally{try{m||null==y.return||y.return()}finally{if(p)throw I;}}}},CallExpression:function(a){if(S(a.callee)){var d=e[e.length-1],h=b[b.length-1],l=d.get(h);l||
(l=[],d.set(h,l));l.push(a.callee)}}}}},"exhaustive-deps":{meta:{fixable:"code",schema:[{type:"object",additionalProperties:!1,properties:{additionalHooks:{type:"string"}}}]},create:function(a){function e(a,d){return function(b){if(d.has(b))return d.get(b);var e=a(b);d.set(b,e);return e}}function b(b){function k(a){var c=!0,f=!1,d=void 0;try{for(var e=a.references[Symbol.iterator](),h;!(c=(h=e.next()).done);c=!0){var g=h.value;if(g.resolved&&I.has(g.resolved.scope)){var m=Y(b,g.identifier),l=fa(m),
p=X(l),r;if(r=A&&"Identifier"===l.type&&"MemberExpression"===l.parent.type&&!l.parent.computed&&"Identifier"===l.parent.property.type&&"current"===l.parent.property.name){for(var q=g.from,u=!1;q.block!==b;)"function"===q.type&&(u=null!=q.block.parent&&"ReturnStatement"===q.block.parent.type),q=q.upper;r=u}r&&R.set(p,{reference:g,dependencyNode:l});var t=g.resolved.defs[0];if(null!=t&&(null==t.node||t.node.init!==b.parent)&&"TypeParameter"!==t.type)if(y.has(p))y.get(p).references.push(g);else{var w=
g.resolved,z=K(w)||W(w);y.set(p,{isStatic:z,references:[g]})}}}}catch(Z){f=!0,d=Z}finally{try{c||null==e.return||e.return()}finally{if(f)throw d;}}c=!0;f=!1;d=void 0;try{for(var v=a.childScopes[Symbol.iterator](),x;!(c=(x=v.next()).done);c=!0)k(x.value)}catch(Z){f=!0,d=Z}finally{try{c||null==v.return||v.return()}finally{if(f)throw d;}}}function F(a,n,f,d){return 0===a.size?null:(1<a.size?"":n+" ")+f+" "+(1<a.size?"dependencies":"dependency")+": "+ma(Array.from(a).sort().map(function(a){return"'"+
a+"'"}))+(". Either "+d+" "+(1<a.size?"them":"it")+" or remove the dependency array.")}if(("FunctionExpression"===b.type||"ArrowFunctionExpression"===b.type)&&"CallExpression"===b.parent.type){var g=ka(b.parent.callee,h);if(b.parent.arguments[g]===b){var u=b.parent.callee,x=ja(u).name,A=x.endsWith("Effect"),m=b.parent.arguments[g+1];if(m||A){A&&b.async&&a.report({node:b,message:"Effect callbacks are synchronous to prevent race conditions. Put the async function inside:\n\nuseEffect(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://fb.me/react-hooks-data-fetching"});
var p=a.getScope(),I=new Set,t=null;for(g=p.upper;g;){I.add(g);if("function"===g.type)break;g=g.upper}if(g){t=g;var K=e(function(a){if(!Array.isArray(a.defs))return!1;var c=a.defs[0];if(null==c||"VariableDeclarator"!==c.node.type)return!1;var f=c.node.init;if(null==f)return!1;var b=c.node.parent;if(null==b&&(Y(t.block,c.node.id),b=c.node.parent,null==b))return!1;if("const"===b.kind&&"Literal"===f.type&&("string"===typeof f.value||"number"===typeof f.value||null===f.value))return!0;if("CallExpression"!==
f.type)return!1;f=f.callee;"MemberExpression"!==f.type||"React"!==f.object.name||null==f.property||f.computed||(f=f.property);if("Identifier"!==f.type)return!1;c=c.node.id;f=f.name;if("useRef"===f&&"Identifier"===c.type)return!0;if(("useState"===f||"useReducer"===f)&&"ArrayPattern"===c.type&&2===c.elements.length&&Array.isArray(a.identifiers)){if(c.elements[1]===a.identifiers[0]){if("useState"===f)for(a=a.references,f=0;f<a.length;f++)d.set(a[f].identifier,c.elements[0]);return!0}if(c.elements[0]===
a.identifiers[0]&&"useState"===f)for(a=a.references,c=0;c<a.length;c++)z.add(a[c].identifier)}return!1},l),W=e(function(a){if(!Array.isArray(a.defs))return!1;a=a.defs[0];if(null==a||null==a.node||null==a.node.id)return!1;var c=a.node,f=t.childScopes;a=null;var b;for(b=0;b<f.length;b++){var d=f[b],e=d.block;if("FunctionDeclaration"===c.type&&e===c||"VariableDeclarator"===c.type&&e.parent===c){a=d;break}}if(null==a)return!1;for(b=0;b<a.through.length;b++)if(c=a.through[b],null!=c.resolved&&I.has(c.resolved.scope)&&
!K(c.resolved))return!1;return!0},v),R=new Map,y=new Map;k(p);R.forEach(function(c,b){var f=c.dependencyNode;c=c.reference.resolved.references;for(var d=!1,e=0;e<c.length;e++){var n=c[e].identifier.parent;if(null!=n&&"MemberExpression"===n.type&&!n.computed&&"Identifier"===n.property.type&&"current"===n.property.name&&"AssignmentExpression"===n.parent.type&&n.parent.left===n){d=!0;break}}d||a.report({node:f.parent.property,message:"The ref value '"+b+".current' will likely have changed by the time this effect cleanup function runs. If this ref points to a node rendered by React, copy "+
("'"+b+".current' to a variable inside the effect, and ")+"use that variable in the cleanup function."})});var P=new Set,E=new Set;y.forEach(function(c,b){var f=c.references;c.isStatic&&E.add(b);f.forEach(function(c){c.writeExpr&&(c=c.writeExpr,P.has(b)||(P.add(b),a.report({node:c,message:"Assignments to the '"+b+"' variable from inside React Hook "+(a.getSource(u)+" will be lost after each ")+"render. To preserve the value over time, store it in a useRef Hook and keep the mutable value in the '.current' property. Otherwise, you can move this variable directly inside "+
(a.getSource(u)+".")})))})});if(!(0<P.size))if(m){var D=[],M=new Set;"ArrayExpression"!==m.type?a.report({node:m,message:"React Hook "+a.getSource(u)+" was passed a dependency list that is not an array literal. This means we can't statically verify whether you've passed the correct dependencies."}):m.elements.forEach(function(c){if(null!==c)if("SpreadElement"===c.type)a.report({node:c,message:"React Hook "+a.getSource(u)+" has a spread element in its dependency array. This means we can't statically verify whether you've passed the correct dependencies."});
else{try{var b=X(c)}catch(ia){if(/Unsupported node type/.test(ia.message)){"Literal"===c.type?y.has(c.value)?a.report({node:c,message:"The "+c.raw+" literal is not a valid dependency because it never changes. "+("Did you mean to include "+c.value+" in the array instead?")}):a.report({node:c,message:"The "+c.raw+" literal is not a valid dependency because it never changes. You can safely remove it."}):a.report({node:c,message:"React Hook "+a.getSource(u)+" has a complex expression in the dependency array. Extract it to a separate variable so it can be statically checked."});
return}throw ia;}for(var f=c;"MemberExpression"===f.type;)f=f.object;var d=!t.through.some(function(a){return a.identifier===f});D.push({key:b,node:c});d||M.add(b)}});var J=V({dependencies:y,declaredDependencies:D,optionalDependencies:E,externalDependencies:M,isEffect:A}),T=J.suggestedDependencies;g=J.unnecessaryDependencies;var H=J.missingDependencies;J=J.duplicateDependencies;if(0===J.size+H.size+g.size)da({declaredDependencies:D,declaredDependenciesNode:m,componentScope:t,scope:p}).forEach(function(c){var b=
c.fn,f=c.suggestUseCallback;c="The '"+b.name.name+"' function makes the dependencies of "+(x+" Hook (at line "+m.loc.start.line+") ")+"change on every render.";c=f?c+(" To fix this, "+("wrap the '"+b.name.name+"' definition into its own useCallback() Hook.")):c+(" Move it inside the "+x+" callback. "+("Alternatively, wrap the '"+b.name.name+"' definition into its own useCallback() Hook."));a.report({node:b.node,message:c,fix:function(a){if(f&&"Variable"===b.type)return[a.insertTextBefore(b.node.init,
"useCallback("),a.insertTextAfter(b.node.init,")")]}})});else{!A&&0<H.size&&(T=V({dependencies:y,declaredDependencies:[],optionalDependencies:E,externalDependencies:M,isEffect:A}).suggestedDependencies);(function(){if(0===D.length)return!0;var a=D.map(function(a){return a.key}),b=a.slice().sort();return a.join(",")===b.join(",")})()&&T.sort();var w="";if(0<g.size){var N=null;Array.from(g.keys()).forEach(function(a){null===N&&a.endsWith(".current")&&(N=a)});if(null!==N)w=" Mutable values like '"+N+
"' aren't valid dependencies because mutating them doesn't re-render the component.";else if(0<M.size){var r=Array.from(M)[0];p.set.has(r)||(w=" Outer scope values like '"+r+"' aren't valid dependencies because mutating them doesn't re-render the component.")}}if(!w&&H.has("props")){p=y.get("props");if(null==p)return;p=p.references;if(!Array.isArray(p))return;r=!0;for(var U=0;U<p.length;U++){var O=Y(t.block,p[U].identifier);if(!O){r=!1;break}O=O.parent;if(null==O){r=!1;break}if("MemberExpression"!==
O.type){r=!1;break}}r&&(w=" However, 'props' will change when *any* prop changes, so the preferred fix is to destructure the 'props' object outside of "+("the "+x+" call and refer to those specific props ")+("inside "+a.getSource(u)+"."))}if(!w&&0<H.size){var Q=null;H.forEach(function(a){if(!Q){var c=t.set.get(a),b=y.get(a);if(b.references[0].resolved===c&&(c=c.defs[0],null!=c&&null!=c.name&&"Parameter"===c.type)){c=!1;for(var d,e=0;e<b.references.length;e++)if(d=b.references[e].identifier,null!=
d&&null!=d.parent&&"CallExpression"===d.parent.type&&d.parent.callee===d){c=!0;break}c&&(Q=a)}}});null!==Q&&(w=" If '"+Q+"' changes too often, find the parent component that defines it and wrap that definition in useCallback.")}if(!w&&0<H.size){var q=null;H.forEach(function(a){if(null===q)for(var c=y.get(a).references,b,e,g=0;g<c.length;g++){b=c[g].identifier;for(e=b.parent;null!=e&&e!==t.block;){if("CallExpression"===e.type){var h=d.get(e.callee);if(null!=h){h.name===a?q={missingDep:a,setter:e.callee.name,
form:"updater"}:z.has(b)?q={missingDep:a,setter:e.callee.name,form:"reducer"}:(b=c[g].resolved,null!=b&&(b=b.defs[0],null!=b&&"Parameter"===b.type&&(q={missingDep:a,setter:e.callee.name,form:"inlineReducer"})));break}}e=e.parent}if(null!==q)break}});if(null!==q)switch(q.form){case "reducer":w=" You can also replace multiple useState variables with useReducer "+("if '"+q.setter+"' needs the ")+("current value of '"+q.missingDep+"'.");break;case "inlineReducer":w=" If '"+q.setter+"' needs the "+("current value of '"+
q.missingDep+"', ")+"you can also switch to useReducer instead of useState and "+("read '"+q.missingDep+"' in the reducer.");break;case "updater":w=" You can also do a functional update '"+q.setter+"("+q.missingDep.substring(0,1)+" => ...)' if you only need '"+q.missingDep+"'"+(" in the '"+q.setter+"' call.");break;default:throw Error("Unknown case.");}}a.report({node:m,message:"React Hook "+a.getSource(u)+" has "+(F(H,"a","missing","include")||F(g,"an","unnecessary","exclude")||F(J,"a","duplicate",
"omit"))+w,fix:function(a){return a.replaceText(m,"["+T.join(", ")+"]")}})}}else{var G=null;y.forEach(function(a,e){G||a.references.forEach(function(a){if(!G&&d.has(a.identifier)){for(a=a.from;"function"!==a.type;)a=a.upper;a.block===b&&(G=e)}})});if(G){var ha=V({dependencies:y,declaredDependencies:[],optionalDependencies:E,externalDependencies:new Set,isEffect:!0}).suggestedDependencies;a.report({node:b.parent.callee,message:"React Hook "+x+" contains a call to '"+G+"'. Without a list of dependencies, this can lead to an infinite chain of updates. To fix this, pass ["+
ha.join(", ")+("] as a second argument to the "+x+" Hook."),fix:function(a){return a.insertTextAfter(b,", ["+ha.join(", ")+"]")}})}}}}else"useMemo"!==x&&"useCallback"!==x||a.report({node:b.parent.callee,message:"React Hook "+x+" does nothing when called with only one argument. Did you forget to pass an array of dependencies?"})}}}var h={additionalHooks:a.options&&a.options[0]&&a.options[0].additionalHooks?new RegExp(a.options[0].additionalHooks):void 0},d=new WeakMap,z=new WeakSet,l=new WeakMap,v=
new WeakMap;return{FunctionExpression:b,ArrowFunctionExpression:b}}}}};
